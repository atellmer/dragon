{"version":3,"file":"react-drag-on.production.min.js","mappings":"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","sources":["webpack://ReactDragOn/webpack/universalModuleDefinition","webpack://ReactDragOn/external umd {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","webpack://ReactDragOn/webpack/bootstrap","webpack://ReactDragOn/webpack/runtime/compat get default export","webpack://ReactDragOn/webpack/runtime/define property getters","webpack://ReactDragOn/webpack/runtime/hasOwnProperty shorthand","webpack://ReactDragOn/webpack/runtime/make namespace object","webpack://ReactDragOn/./src/context.tsx","webpack://ReactDragOn/./src/utils.ts","webpack://ReactDragOn/./src/dom.ts","webpack://ReactDragOn/./src/droppable.tsx","webpack://ReactDragOn/./src/draggable.tsx"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ReactDragOn\", [\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactDragOn\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactDragOn\"] = factory(root[\"React\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__787__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__787__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import React, { useReducer, createContext, useMemo, useContext } from 'react';\r\n\r\nimport { ID } from './types';\r\n\r\nexport type DragDropContextProps = {\r\n  onDragEnd: (options: OnDragEndOptions) => void;\r\n  children: React.ReactNode;\r\n};\r\n\r\nconst DragDropContext: React.FC<DragDropContextProps> = props => {\r\n  const { children, onDragEnd } = props;\r\n  const contextID = useMemo(() => getNextContextID(), []);\r\n  const [state, dispatch] = useReducer(reducer, inititalState);\r\n  const mergeState = (value: Partial<ContextState>) => dispatch({ value });\r\n  const resetState = () => {\r\n    state.unsubscribers.forEach(fn => fn());\r\n    mergeState({\r\n      isDragging: false,\r\n      activeDroppableID: null,\r\n      activeDraggableID: null,\r\n      nodeWidth: null,\r\n      nodeHeight: null,\r\n      scrollContainer: null,\r\n      unsubscribers: [],\r\n      onInsertPlaceholder: null,\r\n    });\r\n  };\r\n  const value = useMemo(() => {\r\n    state.contextID = contextID;\r\n\r\n    return {\r\n      state,\r\n      mergeState,\r\n      resetState,\r\n      onDragEnd,\r\n    };\r\n  }, [state, onDragEnd]);\r\n\r\n  return <Context.Provider value={value}>{children}</Context.Provider>;\r\n};\r\n\r\nexport type DragDropContextValue = {\r\n  state: ContextState;\r\n  mergeState: (state: Partial<ContextState>) => void;\r\n  resetState: () => void;\r\n  onDragEnd: (options: OnDragEndOptions) => void;\r\n};\r\n\r\ntype ContextState = {\r\n  isDragging: boolean;\r\n  contextID: number;\r\n  activeDroppableID: ID;\r\n  activeDroppableGroupID: ID;\r\n  activeDraggableID: ID;\r\n  nodeWidth: number;\r\n  nodeHeight: number;\r\n  scrollContainer: HTMLElement;\r\n  unsubscribers: Array<() => void>;\r\n  onInsertPlaceholder: () => void;\r\n};\r\n\r\nconst Context = createContext<DragDropContextValue>(null);\r\n\r\nconst inititalState: ContextState = {\r\n  isDragging: false,\r\n  contextID: null,\r\n  activeDroppableID: null,\r\n  activeDroppableGroupID: null,\r\n  activeDraggableID: null,\r\n  nodeWidth: null,\r\n  nodeHeight: null,\r\n  scrollContainer: null,\r\n  unsubscribers: [],\r\n  onInsertPlaceholder: null,\r\n};\r\n\r\nlet nextContextID = 0;\r\n\r\nfunction getNextContextID() {\r\n  return ++nextContextID;\r\n}\r\n\r\nfunction reducer(state: ContextState, action: { value: Partial<ContextState> }) {\r\n  return {\r\n    ...state,\r\n    ...action.value,\r\n  };\r\n}\r\n\r\nfunction useDragDropContext() {\r\n  const value = useContext(Context);\r\n\r\n  return value;\r\n}\r\n\r\nexport type OnDragEndOptions = {\r\n  draggableID: ID;\r\n  droppableID: ID;\r\n  droppableGroupID: ID;\r\n  sourceIdx: number;\r\n  destinationIdx: number;\r\n  isMoving: boolean;\r\n  targetRect: DOMRect;\r\n};\r\n\r\nexport { DragDropContext, useDragDropContext };\r\n","import { OnDragEndOptions } from './context';\r\nimport { ID } from './types';\r\n\r\nfunction createBooleanMap<T = any>(items: Array<T> = [], getID: (item: T) => number | string): Record<string, boolean> {\r\n  return items.reduce((acc, x) => ((acc[getID(x)] = true), acc), {});\r\n}\r\n\r\nfunction debounce<T extends (...args) => void>(fn: T, timeout = 0): T {\r\n  let timerID = null;\r\n  const debounced: any = (...args) => {\r\n    timerID && clearTimeout(timerID);\r\n    timerID = setTimeout(() => {\r\n      fn(...args);\r\n    }, timeout);\r\n  };\r\n\r\n  return debounced;\r\n}\r\n\r\ntype ReorderOptions<T> = {\r\n  items: Array<T>;\r\n  getDroppableID: (x: T) => ID;\r\n  getDraggableID: (x: T) => ID;\r\n} & OnDragEndOptions;\r\n\r\nfunction reorder<T>(options: ReorderOptions<T>) {\r\n  const { items, sourceIdx, destinationIdx, droppableID, getDroppableID, getDraggableID } = options;\r\n  const droppableItems = items.filter(x => getDroppableID(x) === droppableID);\r\n  const idsMap = createBooleanMap(droppableItems, x => getDraggableID(x));\r\n  const [removed] = droppableItems.splice(sourceIdx, 1);\r\n\r\n  droppableItems.splice(destinationIdx, 0, removed);\r\n\r\n  const result = [...items.filter(x => !idsMap[getDraggableID(x)]), ...droppableItems];\r\n\r\n  return result;\r\n}\r\n\r\ntype MoveOptions<T> = {\r\n  items: Array<T>;\r\n  getDroppableID: (x: T) => ID;\r\n  setDroppableID: (x: T, droppableID: ID) => void;\r\n  getDraggableID: (x: T) => ID;\r\n} & OnDragEndOptions;\r\n\r\nfunction move<T>(options: MoveOptions<T>) {\r\n  const { items, destinationIdx, droppableID, draggableID, getDroppableID, getDraggableID, setDroppableID } = options;\r\n  const droppableItems = items.filter(x => getDroppableID(x) === droppableID);\r\n  const idsMap = createBooleanMap(droppableItems, x => getDraggableID(x));\r\n  const idx = items.findIndex(x => getDraggableID(x) === draggableID);\r\n  const item = items[idx];\r\n\r\n  setDroppableID(item, droppableID);\r\n  items.splice(idx, 1);\r\n  droppableItems.splice(destinationIdx, 0, item);\r\n\r\n  const result = [...items.filter(x => !idsMap[getDraggableID(x)]), ...droppableItems];\r\n\r\n  return result;\r\n}\r\n\r\nexport { debounce, reorder, move };\r\n","import { ID, Pointer } from './types';\r\n\r\nconst CONTEXT_ID_ATTR = 'data-dnd-context-id';\r\nconst DROPPABLE_ID_ATTR = 'data-dnd-droppable-id';\r\nconst DRAGGABLE_ID_ATTR = 'data-dnd-draggable-id';\r\n\r\nfunction setStyles(node: HTMLElement, style: Record<string, string | number>) {\r\n  const namesMap = {\r\n    zIndex: 'z-index',\r\n    transformOrigin: 'transform-origin',\r\n  };\r\n  const keys = Object.keys(style);\r\n\r\n  for (const key of keys) {\r\n    const propertyName = namesMap[key] || key;\r\n    const value = `${style[key]}`;\r\n\r\n    node.style.setProperty(propertyName, value);\r\n  }\r\n}\r\n\r\nfunction removeStyles(node: HTMLElement, keys: Array<string>) {\r\n  for (const key of keys) {\r\n    if (node.style.getPropertyValue(key)) {\r\n      node.style.removeProperty(key);\r\n    }\r\n  }\r\n\r\n  removeStyleAttrIfEmpty(node);\r\n}\r\n\r\nfunction getItemNodes(contextID: ID, droppableID: ID): Array<HTMLElement> {\r\n  return Array.from(\r\n    document.querySelectorAll(\r\n      `[${CONTEXT_ID_ATTR}=\"${contextID}\"][${DROPPABLE_ID_ATTR}=\"${droppableID}\"][${DRAGGABLE_ID_ATTR}]`,\r\n    ),\r\n  );\r\n}\r\n\r\nfunction detectIsActiveDraggableNode(node: HTMLElement, activeDraggableID: ID) {\r\n  return node.getAttribute(DRAGGABLE_ID_ATTR) === `${activeDraggableID}`;\r\n}\r\n\r\nfunction getActiveDraggableNode(contextID: number, activeDraggableID: ID) {\r\n  return document.querySelector(`[${CONTEXT_ID_ATTR}=\"${contextID}\"][${DRAGGABLE_ID_ATTR}=\"${activeDraggableID}\"]`);\r\n}\r\n\r\nfunction getScrollContainer(node: HTMLElement): HTMLElement {\r\n  let style = getComputedStyle(node);\r\n  const excludeStaticParent = style.position === 'absolute';\r\n  const overflowRegex = /(auto|scroll)/;\r\n\r\n  if (style.position === 'fixed') return document.body;\r\n\r\n  for (let parent = node; (parent = parent.parentElement); ) {\r\n    style = getComputedStyle(parent);\r\n\r\n    if (excludeStaticParent && style.position === 'static') {\r\n      continue;\r\n    }\r\n\r\n    if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) return parent;\r\n  }\r\n\r\n  return document.body;\r\n}\r\n\r\nfunction getScrollContainerFromContainer(node: HTMLElement): HTMLElement {\r\n  const style = getComputedStyle(node);\r\n  const overflowRegex = /(auto|scroll)/;\r\n\r\n  if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) {\r\n    return node;\r\n  }\r\n\r\n  return getScrollContainer(node);\r\n}\r\n\r\nfunction getNodeSize(node: HTMLElement, rect: DOMRect) {\r\n  const style = window.getComputedStyle(node);\r\n  const marginTop = parseInt(style.marginTop);\r\n  const marginBottom = parseInt(style.marginBottom);\r\n  const marginRight = parseInt(style.marginRight);\r\n  const marginLeft = parseInt(style.marginLeft);\r\n  const nodeWidth = rect.width + marginLeft + marginRight;\r\n  const nodeHeight = rect.height + marginTop + marginBottom;\r\n\r\n  return {\r\n    nodeWidth,\r\n    nodeHeight,\r\n  };\r\n}\r\n\r\nfunction getThreshold(rect: DOMRect, pointer: Pointer) {\r\n  const { top, left } = rect;\r\n  const thresholdY = top > 0 ? top : pointer.clientY < window.innerHeight / 2 ? 0 : window.innerHeight;\r\n  const thresholdX = left > 0 ? left : pointer.clientX < window.innerWidth / 2 ? 0 : window.innerWidth;\r\n\r\n  return {\r\n    thresholdY,\r\n    thresholdX,\r\n  };\r\n}\r\n\r\nfunction blockScroll(node: HTMLElement) {\r\n  const overflowValue = node.style.getPropertyValue('overflow');\r\n\r\n  node.style.setProperty('overflow', 'hidden');\r\n\r\n  return () => {\r\n    if (overflowValue) {\r\n      node.style.setProperty('overflow', overflowValue);\r\n    } else {\r\n      node.style.removeProperty('overflow');\r\n    }\r\n\r\n    removeStyleAttrIfEmpty(node);\r\n  };\r\n}\r\n\r\nfunction removeStyleAttrIfEmpty(node: HTMLElement) {\r\n  if (!node.getAttribute('style')) {\r\n    node.removeAttribute('style');\r\n  }\r\n}\r\n\r\nexport {\r\n  CONTEXT_ID_ATTR,\r\n  DROPPABLE_ID_ATTR,\r\n  DRAGGABLE_ID_ATTR,\r\n  setStyles,\r\n  removeStyles,\r\n  getItemNodes,\r\n  detectIsActiveDraggableNode,\r\n  getActiveDraggableNode,\r\n  getScrollContainer,\r\n  getScrollContainerFromContainer,\r\n  getNodeSize,\r\n  getThreshold,\r\n  blockScroll,\r\n};\r\n","import React, { useRef, useLayoutEffect, useEffect, memo, useMemo, createContext, useContext } from 'react';\r\n\r\nimport { debounce } from './utils';\r\nimport { useDragDropContext } from './context';\r\nimport {\r\n  CONTEXT_ID_ATTR,\r\n  DROPPABLE_ID_ATTR,\r\n  setStyles,\r\n  removeStyles,\r\n  getItemNodes,\r\n  detectIsActiveDraggableNode,\r\n  getActiveDraggableNode,\r\n  getScrollContainerFromContainer,\r\n  getThreshold,\r\n} from './dom';\r\nimport { ID, Direction, Pointer } from './types';\r\n\r\nexport type DroppableProps = {\r\n  direction: Direction;\r\n  droppableID: ID;\r\n  droppableGroupID: ID;\r\n  transitionTimeout?: number;\r\n  children: (options: DroppableChildrenOptions) => React.ReactElement;\r\n  onDragOver?: (options: OnDragOverOptions) => void;\r\n};\r\n\r\nconst Droppable: React.FC<DroppableProps> = memo(props => {\r\n  const { droppableID, droppableGroupID, direction, transitionTimeout = 200, children, onDragOver = () => {} } = props;\r\n  const { state, mergeState, resetState, onDragEnd } = useDragDropContext();\r\n  const {\r\n    isDragging: isSomeDragging,\r\n    contextID,\r\n    nodeWidth,\r\n    nodeHeight,\r\n    activeDraggableID,\r\n    activeDroppableID,\r\n    activeDroppableGroupID,\r\n    onInsertPlaceholder,\r\n  } = state;\r\n  const isActiveGroup = droppableGroupID === activeDroppableGroupID;\r\n  const isActive = isActiveGroup && droppableID === activeDroppableID;\r\n  const isDragging = isSomeDragging && isActive;\r\n  const rootRef = useRef<HTMLElement>(null);\r\n  const nodes = useMemo(() => (rootRef.current ? getItemNodes(contextID, droppableID) : []), [isDragging]);\r\n\r\n  const handleDragEnd = () => {\r\n    const sourceIdx = nodes.findIndex(x => detectIsActiveDraggableNode(x, activeDraggableID));\r\n    const targetRect = getActiveDraggableNode(contextID, activeDraggableID).getBoundingClientRect();\r\n    const isMoving = sourceIdx === -1;\r\n    let destinationIdx = 0;\r\n\r\n    for (const node of nodes) {\r\n      const rect = node.getBoundingClientRect();\r\n      const map: Record<DroppableProps['direction'], () => void> = {\r\n        vertical: () => {\r\n          if (targetRect.top + targetRect.height > rect.top + rect.height) {\r\n            destinationIdx++;\r\n          }\r\n        },\r\n        horizontal: () => {\r\n          if (targetRect.left + targetRect.width > rect.left + rect.width) {\r\n            destinationIdx++;\r\n          }\r\n        },\r\n      };\r\n\r\n      removeStyles(node, ['transition', 'transform']);\r\n\r\n      map[direction]();\r\n    }\r\n\r\n    resetState();\r\n    onDragEnd({\r\n      draggableID: activeDraggableID,\r\n      droppableID,\r\n      droppableGroupID,\r\n      sourceIdx,\r\n      destinationIdx,\r\n      isMoving,\r\n      targetRect,\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (isDragging) return;\r\n    setTimeout(() => {\r\n      nodes.forEach(x => {\r\n        removeStyles(x, ['transition', 'transform']);\r\n      });\r\n    });\r\n  }, [isDragging]);\r\n\r\n  useIntersectionEffect({\r\n    contextID,\r\n    activeDraggableID,\r\n    activeDroppableID,\r\n    isActiveGroup,\r\n    isActive,\r\n    isSomeDragging,\r\n    rootNode: rootRef.current,\r\n    onIntersect: () => {\r\n      mergeState({\r\n        activeDroppableID: droppableID,\r\n        scrollContainer: getScrollContainerFromContainer(rootRef.current),\r\n        onInsertPlaceholder: () => {},\r\n      });\r\n    },\r\n  });\r\n\r\n  usePlaceholderEffect({\r\n    isDragging,\r\n    nodeWidth,\r\n    nodeHeight,\r\n    container: rootRef.current,\r\n    onInsertPlaceholder,\r\n  });\r\n\r\n  useMoveSensorEffect({\r\n    isDragging,\r\n    transformNodesByTargetOptions: {\r\n      direction,\r\n      nodes,\r\n      activeDraggableID,\r\n      nodeHeight,\r\n      nodeWidth,\r\n      transitionTimeout,\r\n      onMarkNearestNode: (nearestNode, nearestNodeRect, targetRect) => {\r\n        onDragOver({ nearestNode, nearestNodeRect, targetRect });\r\n      },\r\n    },\r\n  });\r\n\r\n  useEndSensorEffect({\r\n    isDragging,\r\n    onDragEnd: handleDragEnd,\r\n  });\r\n\r\n  const contextValue = useMemo<DroppableContextValue>(\r\n    () => ({\r\n      direction,\r\n      droppableID,\r\n      droppableGroupID,\r\n    }),\r\n    [direction, droppableID, droppableGroupID],\r\n  );\r\n\r\n  return (\r\n    <DroppableContext.Provider value={contextValue}>\r\n      {children({\r\n        ref: rootRef,\r\n        [CONTEXT_ID_ATTR]: contextID,\r\n        [DROPPABLE_ID_ATTR]: droppableID,\r\n        snapshot: {\r\n          isDragging,\r\n        },\r\n        onDragStart: defaultHandleDragStart,\r\n      })}\r\n    </DroppableContext.Provider>\r\n  );\r\n});\r\n\r\ntype DroppableContextValue = {} & Pick<DroppableProps, 'direction' | 'droppableID' | 'droppableGroupID'>;\r\n\r\nconst DroppableContext = createContext<DroppableContextValue>(null);\r\n\r\nfunction useDroppableContext() {\r\n  return useContext(DroppableContext);\r\n}\r\n\r\nconst defaultHandleDragStart = (e: React.MouseEvent) => e.preventDefault();\r\n\r\nexport type DroppableChildrenOptions = {\r\n  ref: React.Ref<any>;\r\n  [CONTEXT_ID_ATTR]: number;\r\n  [DROPPABLE_ID_ATTR]: ID;\r\n  snapshot: {\r\n    isDragging: boolean;\r\n  };\r\n  onDragStart: React.DragEventHandler;\r\n};\r\n\r\nexport type OnDragOverOptions = {\r\n  nearestNode: HTMLElement | null;\r\n  nearestNodeRect: DOMRect;\r\n  targetRect: DOMRect;\r\n};\r\n\r\ntype UseIntersectionEffectOptions = {\r\n  isSomeDragging: boolean;\r\n  isActiveGroup: boolean;\r\n  isActive: boolean;\r\n  rootNode: HTMLElement;\r\n  contextID: number;\r\n  activeDroppableID: ID;\r\n  activeDraggableID: ID;\r\n  onIntersect: () => void;\r\n};\r\n\r\nfunction useIntersectionEffect(options: UseIntersectionEffectOptions) {\r\n  const {\r\n    isSomeDragging,\r\n    isActiveGroup,\r\n    isActive,\r\n    rootNode,\r\n    contextID,\r\n    activeDroppableID,\r\n    activeDraggableID,\r\n    onIntersect,\r\n  } = options;\r\n\r\n  useEffect(() => {\r\n    const handleEvent = () => {\r\n      if (!isSomeDragging) return;\r\n      if (!isActiveGroup) return;\r\n      if (isActive) return;\r\n      const droppableRect = rootNode.getBoundingClientRect();\r\n      const draggingRect = getActiveDraggableNode(contextID, activeDraggableID).getBoundingClientRect();\r\n      const isYaxesIntersected =\r\n        draggingRect.top > droppableRect.top && draggingRect.top < droppableRect.top + droppableRect.height;\r\n      const isXaxesIntersected =\r\n        draggingRect.left > droppableRect.left && draggingRect.left < droppableRect.left + droppableRect.width;\r\n\r\n      if (isYaxesIntersected && isXaxesIntersected) {\r\n        onIntersect();\r\n      }\r\n    };\r\n\r\n    document.addEventListener('mousemove', handleEvent);\r\n    document.addEventListener('touchmove', handleEvent);\r\n\r\n    return () => {\r\n      document.removeEventListener('mousemove', handleEvent);\r\n      document.removeEventListener('touchmove', handleEvent);\r\n    };\r\n  }, [isSomeDragging, activeDroppableID, rootNode]);\r\n}\r\n\r\ntype UsePlaceholderEffectOptions = {\r\n  isDragging: boolean;\r\n  nodeWidth: number;\r\n  nodeHeight: number;\r\n  container: HTMLElement;\r\n  onInsertPlaceholder: () => void;\r\n};\r\n\r\nfunction usePlaceholderEffect(options: UsePlaceholderEffectOptions) {\r\n  const { isDragging, nodeWidth, nodeHeight, container, onInsertPlaceholder } = options;\r\n\r\n  useLayoutEffect(() => {\r\n    let placeholder = null;\r\n\r\n    if (isDragging) {\r\n      placeholder = document.createElement('div');\r\n\r\n      setStyles(placeholder, {\r\n        width: `${nodeWidth}px`,\r\n        height: `${nodeHeight}px`,\r\n        flex: `0 0 auto`,\r\n      });\r\n\r\n      container.appendChild(placeholder);\r\n      onInsertPlaceholder();\r\n    }\r\n\r\n    return () => placeholder && container.removeChild(placeholder);\r\n  }, [isDragging]);\r\n}\r\n\r\ntype UseMoveSensorEffectOptions = {\r\n  isDragging: boolean;\r\n  transformNodesByTargetOptions: Omit<TransformNodesByTargetOptions, 'target' | 'pointer'>;\r\n};\r\n\r\nfunction useMoveSensorEffect(options: UseMoveSensorEffectOptions) {\r\n  const { isDragging, transformNodesByTargetOptions } = options;\r\n\r\n  useLayoutEffect(() => {\r\n    if (!isDragging) return;\r\n\r\n    const handleEvent = debounce((e: MouseEvent | TouchEvent) => {\r\n      const target = e.target as HTMLElement;\r\n      const pointer: Pointer =\r\n        e instanceof MouseEvent\r\n          ? { clientX: e.clientX, clientY: e.clientY }\r\n          : e instanceof TouchEvent\r\n          ? { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }\r\n          : null;\r\n\r\n      transformNodesByTarget({\r\n        ...transformNodesByTargetOptions,\r\n        target,\r\n        pointer,\r\n      });\r\n    });\r\n\r\n    document.addEventListener('mousemove', handleEvent);\r\n    document.addEventListener('touchmove', handleEvent);\r\n\r\n    return () => {\r\n      document.removeEventListener('mousemove', handleEvent);\r\n      document.removeEventListener('touchmove', handleEvent);\r\n    };\r\n  }, [isDragging]);\r\n}\r\n\r\ntype UseEndSensorEffectOptions = {\r\n  isDragging: boolean;\r\n  onDragEnd: () => void;\r\n};\r\n\r\nfunction useEndSensorEffect(options: UseEndSensorEffectOptions) {\r\n  const { isDragging, onDragEnd } = options;\r\n\r\n  useLayoutEffect(() => {\r\n    if (!isDragging) return;\r\n\r\n    const handleEvent = () => onDragEnd();\r\n\r\n    document.addEventListener('mouseup', handleEvent);\r\n    document.addEventListener('touchend', handleEvent);\r\n\r\n    return () => {\r\n      document.removeEventListener('mouseup', handleEvent);\r\n      document.removeEventListener('touchend', handleEvent);\r\n    };\r\n  }, [isDragging]);\r\n}\r\n\r\ntype TransformNodesByTargetOptions = {\r\n  direction: Direction;\r\n  target: HTMLElement;\r\n  pointer: Pointer;\r\n  nodes: Array<HTMLElement>;\r\n  activeDraggableID: ID;\r\n  nodeHeight: number;\r\n  nodeWidth: number;\r\n  transitionTimeout: number;\r\n  onMarkNearestNode?: (node: HTMLElement, nodeRect: DOMRect, targetRect: DOMRect) => void;\r\n};\r\n\r\nconst transformNodesByTarget = (options: TransformNodesByTargetOptions) => {\r\n  const {\r\n    direction,\r\n    target,\r\n    pointer,\r\n    nodes,\r\n    activeDraggableID,\r\n    nodeHeight,\r\n    nodeWidth,\r\n    transitionTimeout,\r\n    onMarkNearestNode = () => {},\r\n  } = options;\r\n  const targetRect = target.getBoundingClientRect();\r\n  let nearestNode: HTMLElement = null;\r\n  let nearestNodeRect: DOMRect = null;\r\n  let minimalDiff = Infinity;\r\n\r\n  for (const node of nodes) {\r\n    if (detectIsActiveDraggableNode(node, activeDraggableID)) continue;\r\n\r\n    const rect = node.getBoundingClientRect();\r\n    const { thresholdY, thresholdX } = getThreshold(targetRect, pointer);\r\n    const map: Record<Direction, () => void> = {\r\n      vertical: () => {\r\n        if (thresholdY <= rect.top) {\r\n          setStyles(node, {\r\n            transition: `transform ${transitionTimeout}ms ease-in-out`,\r\n            transform: `translate3d(0px, ${nodeHeight}px, 0px)`,\r\n          });\r\n        } else {\r\n          removeStyles(node, ['transform']);\r\n          const diff = thresholdY - rect.top;\r\n\r\n          if (diff < minimalDiff) {\r\n            minimalDiff = diff;\r\n            nearestNode = node;\r\n            nearestNodeRect = rect;\r\n          }\r\n        }\r\n      },\r\n      horizontal: () => {\r\n        if (thresholdX <= rect.left) {\r\n          setStyles(node, {\r\n            transition: `transform ${transitionTimeout}ms ease-in-out`,\r\n            transform: `translate3d(${nodeWidth}px, 0px, 0px)`,\r\n          });\r\n        } else {\r\n          removeStyles(node, ['transform']);\r\n          const diff = thresholdX - rect.left;\r\n\r\n          if (diff < minimalDiff) {\r\n            minimalDiff = diff;\r\n            nearestNode = node;\r\n            nearestNodeRect = rect;\r\n          }\r\n        }\r\n      },\r\n    };\r\n\r\n    map[direction]();\r\n  }\r\n\r\n  onMarkNearestNode(nearestNode, nearestNodeRect, targetRect);\r\n};\r\n\r\nexport { Droppable, useDroppableContext, transformNodesByTarget };\r\n","import React, { useRef, useMemo, useLayoutEffect, memo } from 'react';\r\n\r\nimport { useDragDropContext } from './context';\r\nimport { useDroppableContext, transformNodesByTarget } from './droppable';\r\nimport {\r\n  CONTEXT_ID_ATTR,\r\n  DROPPABLE_ID_ATTR,\r\n  DRAGGABLE_ID_ATTR,\r\n  setStyles,\r\n  removeStyles,\r\n  getScrollContainer,\r\n  getNodeSize,\r\n  blockScroll,\r\n  getItemNodes,\r\n} from './dom';\r\nimport { ID, Pointer, Coordinates } from './types';\r\n\r\nexport type DraggableProps = {\r\n  draggableID: ID;\r\n  children: (options: DraggableChildrenOptions) => React.ReactElement;\r\n};\r\n\r\nconst Draggable: React.FC<DraggableProps> = memo(props => {\r\n  const { draggableID, children } = props;\r\n  const { state, mergeState } = useDragDropContext();\r\n  const { droppableID, droppableGroupID, direction } = useDroppableContext();\r\n  const { contextID, scrollContainer } = state;\r\n  const rootRef = useRef<HTMLDivElement>(null);\r\n  const isActive = state.isDragging && state.activeDraggableID === draggableID;\r\n  const scope = useMemo<DraggableScope>(() => ({ unsubscribers: [], scrollContainer: null }), []);\r\n\r\n  scope.scrollContainer = scrollContainer;\r\n\r\n  useLayoutEffect(() => () => unsubscribe(), []);\r\n\r\n  const unsubscribe = () => {\r\n    scope.unsubscribers.forEach(fn => fn());\r\n    scope.unsubscribers = [];\r\n  };\r\n\r\n  const handleMouseDown = (startEvent: React.MouseEvent) => {\r\n    const node = rootRef.current;\r\n    const rect = node.getBoundingClientRect();\r\n    const scrollContainer = getScrollContainer(node);\r\n    const { nodeWidth, nodeHeight } = getNodeSize(node, rect);\r\n    const startPointer: Pointer = {\r\n      clientX: startEvent.clientX,\r\n      clientY: startEvent.clientY,\r\n    };\r\n\r\n    const handleEvent = (moveEvent: MouseEvent) => {\r\n      const movePointer: Pointer = {\r\n        clientX: moveEvent.clientX,\r\n        clientY: moveEvent.clientY,\r\n      };\r\n\r\n      applyMoveSensor({\r\n        node,\r\n        scrollContainer: scope.scrollContainer,\r\n        startPointer,\r\n        movePointer,\r\n      });\r\n    };\r\n\r\n    const resetEventHandler = () => {\r\n      document.removeEventListener('mousemove', handleEvent);\r\n    };\r\n\r\n    const unsubscribe = () => {\r\n      removeNodeStyles(node);\r\n      resetEventHandler();\r\n    };\r\n\r\n    const handleInsertPlaceholder = () => {\r\n      transformNodesByTarget({\r\n        target: node,\r\n        nodeWidth,\r\n        nodeHeight,\r\n        pointer: startPointer,\r\n        activeDraggableID: draggableID,\r\n        transitionTimeout: 0,\r\n        direction,\r\n        nodes: getItemNodes(contextID, droppableID),\r\n      });\r\n    };\r\n\r\n    setNodeDragStyles(node, rect);\r\n\r\n    mergeState({\r\n      isDragging: true,\r\n      activeDroppableID: droppableID,\r\n      activeDroppableGroupID: droppableGroupID,\r\n      activeDraggableID: draggableID,\r\n      nodeWidth,\r\n      nodeHeight,\r\n      scrollContainer,\r\n      unsubscribers: [...state.unsubscribers, unsubscribe],\r\n      onInsertPlaceholder: handleInsertPlaceholder,\r\n    });\r\n\r\n    scope.unsubscribers.push(resetEventHandler);\r\n    document.addEventListener('mousemove', handleEvent);\r\n  };\r\n\r\n  const handleTouchStart = (startEvent: React.TouchEvent) => {\r\n    const node = rootRef.current;\r\n    const rect = node.getBoundingClientRect();\r\n    const scrollContainer = getScrollContainer(node);\r\n    const { nodeWidth, nodeHeight } = getNodeSize(node, rect);\r\n    const startPointer: Pointer = {\r\n      clientX: startEvent.touches[0].clientX,\r\n      clientY: startEvent.touches[0].clientY,\r\n    };\r\n    const unblockScroll = blockScroll(document.body);\r\n\r\n    const handleEvent = (moveEvent: TouchEvent) => {\r\n      const movePointer: Pointer = {\r\n        clientX: moveEvent.touches[0].clientX,\r\n        clientY: moveEvent.touches[0].clientY,\r\n      };\r\n\r\n      applyMoveSensor({\r\n        node,\r\n        scrollContainer: scope.scrollContainer,\r\n        startPointer,\r\n        movePointer,\r\n      });\r\n    };\r\n\r\n    const resetEventHandler = () => {\r\n      document.removeEventListener('touchmove', handleEvent);\r\n      unblockScroll();\r\n    };\r\n\r\n    const unsubscribe = () => {\r\n      removeNodeStyles(node);\r\n      resetEventHandler();\r\n    };\r\n\r\n    const handleInsertPlaceholder = () => {\r\n      transformNodesByTarget({\r\n        target: node,\r\n        nodeWidth,\r\n        nodeHeight,\r\n        pointer: startPointer,\r\n        activeDraggableID: draggableID,\r\n        transitionTimeout: 0,\r\n        direction,\r\n        nodes: getItemNodes(contextID, droppableID),\r\n      });\r\n    };\r\n\r\n    setNodeDragStyles(node, rect);\r\n\r\n    transformNodesByTarget({\r\n      target: node,\r\n      nodeWidth,\r\n      nodeHeight,\r\n      pointer: startPointer,\r\n      activeDraggableID: draggableID,\r\n      transitionTimeout: 0,\r\n      direction,\r\n      nodes: getItemNodes(contextID, droppableID),\r\n    });\r\n\r\n    mergeState({\r\n      isDragging: true,\r\n      activeDroppableID: droppableID,\r\n      activeDroppableGroupID: droppableGroupID,\r\n      activeDraggableID: draggableID,\r\n      nodeWidth,\r\n      nodeHeight,\r\n      scrollContainer,\r\n      unsubscribers: [...state.unsubscribers, unsubscribe],\r\n      onInsertPlaceholder: handleInsertPlaceholder,\r\n    });\r\n\r\n    scope.unsubscribers.push(resetEventHandler);\r\n\r\n    document.addEventListener('touchmove', handleEvent);\r\n  };\r\n\r\n  return children({\r\n    rootProps: {\r\n      ref: rootRef,\r\n      draggable: false,\r\n      [CONTEXT_ID_ATTR]: contextID,\r\n      [DROPPABLE_ID_ATTR]: droppableID,\r\n      [DRAGGABLE_ID_ATTR]: draggableID,\r\n    },\r\n    draggableProps: {\r\n      onMouseDown: handleMouseDown,\r\n      onTouchStart: handleTouchStart,\r\n    },\r\n    snapshot: {\r\n      isDragging: isActive,\r\n    },\r\n  });\r\n});\r\n\r\ntype DraggableChildrenOptions = {\r\n  rootProps: {\r\n    ref: React.Ref<any>;\r\n    draggable: false;\r\n    [CONTEXT_ID_ATTR]: number;\r\n    [DROPPABLE_ID_ATTR]: ID;\r\n    [DRAGGABLE_ID_ATTR]: ID;\r\n  };\r\n  draggableProps: {\r\n    onMouseDown: (e: React.MouseEvent) => void;\r\n    onTouchStart: (e: React.TouchEvent) => void;\r\n  };\r\n  snapshot: {\r\n    isDragging: boolean;\r\n  };\r\n};\r\n\r\ntype DraggableScope = {\r\n  unsubscribers: Array<() => void>;\r\n  scrollContainer: HTMLElement;\r\n};\r\n\r\ntype ApplyMoveSensorOptions = {\r\n  node: HTMLElement;\r\n  startPointer: Pointer;\r\n  movePointer: Pointer;\r\n  scrollContainer: HTMLElement;\r\n};\r\n\r\nfunction applyMoveSensor(options: ApplyMoveSensorOptions) {\r\n  const { node, startPointer, movePointer, scrollContainer } = options;\r\n  const { x, y } = getCoordinates({ movePointer, startPointer });\r\n\r\n  transformNodePosition(node, { x, y });\r\n\r\n  requestAnimationFrame(() => {\r\n    const isRoot = scrollContainer === document.body;\r\n    const element = isRoot ? window : scrollContainer;\r\n    const velocity = 1000;\r\n\r\n    if (movePointer.clientY > window.innerHeight || movePointer.clientY < 0) {\r\n      const shift = isRoot ? window.scrollY : scrollContainer.scrollTop;\r\n\r\n      element.scroll({\r\n        top: movePointer.clientY > 0 ? movePointer.clientY + shift : movePointer.clientY + shift - velocity,\r\n        behavior: 'smooth',\r\n      });\r\n    }\r\n\r\n    if (movePointer.clientX > window.innerWidth || movePointer.clientX < 0) {\r\n      const shift = isRoot ? window.scrollX : scrollContainer.scrollLeft;\r\n\r\n      element.scroll({\r\n        left: movePointer.clientX > 0 ? movePointer.clientX + shift : movePointer.clientX + shift - velocity,\r\n        behavior: 'smooth',\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\ntype GetCoordinatesOptions = {\r\n  movePointer: Pointer;\r\n  startPointer: Pointer;\r\n};\r\n\r\nfunction getCoordinates(options: GetCoordinatesOptions): Coordinates {\r\n  const { movePointer, startPointer } = options;\r\n  const x = movePointer.clientX - startPointer.clientX;\r\n  const y = movePointer.clientY - startPointer.clientY;\r\n\r\n  return {\r\n    x,\r\n    y,\r\n  };\r\n}\r\n\r\nfunction setNodeDragStyles(node: HTMLElement, rect: DOMRect) {\r\n  const style = window.getComputedStyle(node);\r\n  const marginTop = parseInt(style.marginTop);\r\n  const marginLeft = parseInt(style.marginLeft);\r\n  const top = rect.top - marginTop;\r\n  const left = rect.left - marginLeft;\r\n\r\n  setStyles(node, {\r\n    position: 'fixed',\r\n    zIndex: '100000',\r\n    top: `${top}px`,\r\n    left: `${left}px`,\r\n    width: `${rect.width}px`,\r\n    height: `${rect.height}px`,\r\n    transformOrigin: '0 0',\r\n  });\r\n}\r\n\r\nfunction transformNodePosition(node: HTMLElement, { x, y }: Coordinates) {\r\n  setStyles(node, {\r\n    transition: 'none',\r\n    transform: `translate3D(${x}px, ${y}px, 0px)`,\r\n  });\r\n}\r\n\r\nfunction removeNodeStyles(node: HTMLElement) {\r\n  removeStyles(node, ['position', 'top', 'left', 'z-index', 'width', 'height', 'transform', 'transform-origin']);\r\n}\r\n\r\nexport { Draggable };\r\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__787__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","DragDropContext","props","children","onDragEnd","contextID","useMemo","nextContextID","useReducer","reducer","inititalState","state","dispatch","mergeState","resetState","unsubscribers","forEach","fn","isDragging","activeDroppableID","activeDraggableID","nodeWidth","nodeHeight","scrollContainer","onInsertPlaceholder","Context","Provider","createContext","activeDroppableGroupID","action","useDragDropContext","useContext","createBooleanMap","items","getID","reduce","acc","x","reorder","options","sourceIdx","destinationIdx","droppableID","getDroppableID","getDraggableID","droppableItems","filter","idsMap","removed","splice","move","draggableID","setDroppableID","idx","findIndex","item","CONTEXT_ID_ATTR","DROPPABLE_ID_ATTR","DRAGGABLE_ID_ATTR","setStyles","node","style","namesMap","zIndex","transformOrigin","keys","propertyName","setProperty","removeStyles","getPropertyValue","removeProperty","removeStyleAttrIfEmpty","getItemNodes","Array","from","document","querySelectorAll","detectIsActiveDraggableNode","getAttribute","getActiveDraggableNode","querySelector","getScrollContainer","getComputedStyle","excludeStaticParent","position","overflowRegex","body","parentElement","test","overflow","overflowY","overflowX","getNodeSize","rect","window","marginTop","parseInt","marginBottom","marginRight","marginLeft","width","height","removeAttribute","Droppable","memo","droppableGroupID","direction","transitionTimeout","onDragOver","isSomeDragging","isActiveGroup","isActive","rootRef","useRef","nodes","current","useEffect","setTimeout","rootNode","onIntersect","handleEvent","droppableRect","getBoundingClientRect","draggingRect","isYaxesIntersected","top","isXaxesIntersected","left","addEventListener","removeEventListener","useIntersectionEffect","container","useLayoutEffect","placeholder","createElement","flex","appendChild","removeChild","usePlaceholderEffect","transformNodesByTargetOptions","timeout","timerID","clearTimeout","args","debounce","e","target","pointer","MouseEvent","clientX","clientY","TouchEvent","touches","transformNodesByTarget","useMoveSensorEffect","onMarkNearestNode","nearestNode","nearestNodeRect","targetRect","useEndSensorEffect","isMoving","map","vertical","horizontal","contextValue","DroppableContext","ref","snapshot","onDragStart","defaultHandleDragStart","useDroppableContext","preventDefault","minimalDiff","Infinity","thresholdY","innerHeight","thresholdX","innerWidth","getThreshold","transition","transform","diff","Draggable","scope","unsubscribe","rootProps","draggable","draggableProps","onMouseDown","startEvent","startPointer","moveEvent","movePointer","applyMoveSensor","resetEventHandler","setNodeDragStyles","removeNodeStyles","push","onTouchStart","unblockScroll","overflowValue","blockScroll","y","getCoordinates","transformNodePosition","requestAnimationFrame","isRoot","element","shift","scrollY","scrollTop","scroll","behavior","scrollX","scrollLeft"],"sourceRoot":""}