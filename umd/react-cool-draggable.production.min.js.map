{"version":3,"file":"react-cool-draggable.production.min.js","mappings":"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","sources":["webpack://ReactCoolDraggable/webpack/universalModuleDefinition","webpack://ReactCoolDraggable/external umd {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","webpack://ReactCoolDraggable/webpack/bootstrap","webpack://ReactCoolDraggable/webpack/runtime/compat get default export","webpack://ReactCoolDraggable/webpack/runtime/define property getters","webpack://ReactCoolDraggable/webpack/runtime/hasOwnProperty shorthand","webpack://ReactCoolDraggable/webpack/runtime/make namespace object","webpack://ReactCoolDraggable/./src/utils.ts","webpack://ReactCoolDraggable/./src/context.tsx","webpack://ReactCoolDraggable/./src/droppable.tsx","webpack://ReactCoolDraggable/./src/draggable.tsx","webpack://ReactCoolDraggable/./src/methods.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ReactCoolDraggable\", [\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactCoolDraggable\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactCoolDraggable\"] = factory(root[\"React\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__787__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__787__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { ID, Pointer, DraggableElement } from './types';\r\n\r\nconst CONTEXT_ID_ATTR = 'data-dnd-context-id';\r\nconst DROPPABLE_ID_ATTR = 'data-dnd-droppable-id';\r\nconst DRAGGABLE_ID_ATTR = 'data-dnd-draggable-id';\r\nconst DRAGGABLE_HANDLER_ATTR = 'data-dnd-draggable-handler';\r\nconst GLOBAL_STYLE = 'data-dnd-global-style';\r\n\r\nfunction setStyles(node: DraggableElement, style: Record<string, string | number>) {\r\n  const namesMap = {\r\n    maxWidth: 'max-width',\r\n    maxHeight: 'max-height',\r\n    zIndex: 'z-index',\r\n    transformOrigin: 'transform-origin',\r\n  };\r\n  const keys = Object.keys(style);\r\n\r\n  for (const key of keys) {\r\n    const propertyName = namesMap[key] || key;\r\n    const value = `${style[key]}`;\r\n\r\n    node.style.setProperty(propertyName, value);\r\n  }\r\n}\r\n\r\nfunction removeStyles(node: DraggableElement, keys: Array<string>) {\r\n  for (const key of keys) {\r\n    if (node.style.getPropertyValue(key)) {\r\n      node.style.removeProperty(key);\r\n    }\r\n  }\r\n\r\n  removeStyleAttrIfEmpty(node);\r\n}\r\n\r\nfunction getItemNodes(contextID: ID, droppableID: ID): Array<DraggableElement> {\r\n  return Array.from(\r\n    document.querySelectorAll(\r\n      `[${CONTEXT_ID_ATTR}=\"${contextID}\"][${DROPPABLE_ID_ATTR}=\"${droppableID}\"][${DRAGGABLE_ID_ATTR}]`,\r\n    ),\r\n  );\r\n}\r\n\r\nfunction detectIsActiveDraggableNode(node: DraggableElement, activeDraggableID: ID) {\r\n  return node.getAttribute(DRAGGABLE_ID_ATTR) === `${activeDraggableID}`;\r\n}\r\n\r\nfunction getActiveDraggableNode(contextID: number, activeDraggableID: ID): DraggableElement {\r\n  return document.querySelector(`[${CONTEXT_ID_ATTR}=\"${contextID}\"][${DRAGGABLE_ID_ATTR}=\"${activeDraggableID}\"]`);\r\n}\r\n\r\nfunction getActiveDroppableNode(contextID: number, activeDroppableID: ID): DraggableElement {\r\n  return document.querySelector(`[${CONTEXT_ID_ATTR}=\"${contextID}\"][${DROPPABLE_ID_ATTR}=\"${activeDroppableID}\"]`);\r\n}\r\n\r\nfunction getScrollContainer(node: DraggableElement): DraggableElement {\r\n  let style = getComputedStyle(node);\r\n  const excludeStaticParent = style.position === 'absolute';\r\n  const overflowRegex = /(auto|scroll)/;\r\n\r\n  if (style.position === 'fixed') return document.body;\r\n\r\n  for (let parent = node; (parent = parent.parentElement); ) {\r\n    style = getComputedStyle(parent);\r\n\r\n    if (excludeStaticParent && style.position === 'static') {\r\n      continue;\r\n    }\r\n\r\n    if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) return parent;\r\n  }\r\n\r\n  return document.body;\r\n}\r\n\r\nfunction getScrollContainerFromContainer(node: DraggableElement): DraggableElement {\r\n  const style = getComputedStyle(node);\r\n  const overflowRegex = /(auto|scroll)/;\r\n\r\n  if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) {\r\n    return node;\r\n  }\r\n\r\n  return getScrollContainer(node);\r\n}\r\n\r\nfunction getNodeSize(node: DraggableElement, rect: DOMRect) {\r\n  const style = window.getComputedStyle(node);\r\n  const marginTop = parseInt(style.marginTop, 10);\r\n  const marginBottom = parseInt(style.marginBottom, 10);\r\n  const marginRight = parseInt(style.marginRight, 10);\r\n  const marginLeft = parseInt(style.marginLeft, 10);\r\n  const nodeWidth = safeNumber(rect.width + marginLeft + marginRight);\r\n  const nodeHeight = safeNumber(rect.height + marginTop + marginBottom);\r\n\r\n  return {\r\n    nodeWidth,\r\n    nodeHeight,\r\n  };\r\n}\r\n\r\nfunction safeNumber(value: number, precision = 0) {\r\n  return Number(value.toFixed(precision));\r\n}\r\n\r\nfunction getThreshold(rect: DOMRect, pointer: Pointer) {\r\n  const { top, left } = rect;\r\n  const thresholdY = top > 0 ? top : pointer.clientY < window.innerHeight / 2 ? 0 : window.innerHeight;\r\n  const thresholdX = left > 0 ? left : pointer.clientX < window.innerWidth / 2 ? 0 : window.innerWidth;\r\n\r\n  return {\r\n    thresholdY: safeNumber(thresholdY),\r\n    thresholdX: safeNumber(thresholdX),\r\n  };\r\n}\r\n\r\nfunction removeStyleAttrIfEmpty(node: DraggableElement) {\r\n  if (!node.getAttribute('style')) {\r\n    node.removeAttribute('style');\r\n  }\r\n}\r\n\r\nfunction createBooleanMap<T = any>(items: Array<T> = [], getID: (item: T) => number | string): Record<string, boolean> {\r\n  return items.reduce((acc, x) => ((acc[getID(x)] = true), acc), {});\r\n}\r\n\r\nfunction debounce<T extends (...args) => void>(fn: T, timeout = 0): T {\r\n  let timerID = null;\r\n  const debounced: any = (...args) => {\r\n    timerID && clearTimeout(timerID);\r\n    timerID = setTimeout(() => {\r\n      fn(...args);\r\n    }, timeout);\r\n  };\r\n\r\n  return debounced;\r\n}\r\n\r\nfunction createPointer(e: PointerEvent): Pointer {\r\n  return { clientX: e.clientX, clientY: e.clientY };\r\n}\r\n\r\nexport {\r\n  CONTEXT_ID_ATTR,\r\n  DROPPABLE_ID_ATTR,\r\n  DRAGGABLE_ID_ATTR,\r\n  DRAGGABLE_HANDLER_ATTR,\r\n  GLOBAL_STYLE,\r\n  setStyles,\r\n  removeStyles,\r\n  getItemNodes,\r\n  detectIsActiveDraggableNode,\r\n  getActiveDraggableNode,\r\n  getActiveDroppableNode,\r\n  getScrollContainer,\r\n  getScrollContainerFromContainer,\r\n  getNodeSize,\r\n  safeNumber,\r\n  getThreshold,\r\n  createBooleanMap,\r\n  debounce,\r\n  createPointer,\r\n};\r\n","import React, { useReducer, createContext, useMemo, useContext, useEffect } from 'react';\r\n\r\nimport type { ID, DraggableElement } from './types';\r\nimport { GLOBAL_STYLE, DRAGGABLE_HANDLER_ATTR } from './utils';\r\n\r\nexport type DragDropContextProps = {\r\n  onDragStart?: (options: OnDragStartOptions) => void;\r\n  onDragOver?: (options: OnDragOverOptions) => void;\r\n  onDragEnd: (options: OnDragEndOptions) => void;\r\n  children: React.ReactElement;\r\n};\r\n\r\nconst DragDropContext: React.FC<DragDropContextProps> = props => {\r\n  const { children, onDragStart, onDragOver, onDragEnd } = props;\r\n  const contextID = useMemo(() => getNextContextID(), []);\r\n  const [state, dispatch] = useReducer(reducer, inititalState);\r\n  const mergeState = (value: Partial<ContextState>) => dispatch({ value });\r\n  const resetState = () => {\r\n    state.onComplete();\r\n    mergeState({\r\n      isDragging: false,\r\n      isIntersected: false,\r\n      activeDroppableID: null,\r\n      activeDraggableID: null,\r\n      nodeWidth: null,\r\n      nodeHeight: null,\r\n      scrollContainer: null,\r\n      unsubscribers: [],\r\n      onComplete: null,\r\n      onInsertPlaceholder: null,\r\n    });\r\n  };\r\n  const value = useMemo<DragDropContextValue>(() => {\r\n    state.contextID = contextID;\r\n\r\n    return {\r\n      state,\r\n      mergeState,\r\n      resetState,\r\n      onDragStart,\r\n      onDragOver,\r\n      onDragEnd,\r\n    };\r\n  }, [state, onDragEnd]);\r\n\r\n  useGlobalStyleEffect();\r\n\r\n  return <Context.Provider value={value}>{children}</Context.Provider>;\r\n};\r\n\r\nDragDropContext.defaultProps = {\r\n  onDragStart: () => {},\r\n  onDragOver: () => {},\r\n};\r\n\r\nfunction useGlobalStyleEffect() {\r\n  useEffect(() => {\r\n    const style = document.createElement('style');\r\n\r\n    style.setAttribute(GLOBAL_STYLE, 'true');\r\n    style.textContent = `\r\n      [${DRAGGABLE_HANDLER_ATTR}] {\r\n        touch-action: none;\r\n      }\r\n    `;\r\n\r\n    document.head.appendChild(style);\r\n\r\n    return () => {\r\n      document.head.removeChild(style);\r\n    };\r\n  }, []);\r\n}\r\n\r\nexport type DragDropContextValue = {\r\n  state: ContextState;\r\n  mergeState: (state: Partial<ContextState>) => void;\r\n  resetState: () => void;\r\n  onDragEnd: (options: OnDragEndOptions) => void;\r\n} & Required<Pick<DragDropContextProps, 'onDragStart' | 'onDragOver' | 'onDragEnd'>>;\r\n\r\ntype ContextState = {\r\n  isDragging: boolean;\r\n  isIntersected: boolean;\r\n  contextID: number;\r\n  activeDroppableID: ID;\r\n  activeDroppableGroupID: ID;\r\n  activeDraggableID: ID;\r\n  nodeWidth: number;\r\n  nodeHeight: number;\r\n  scrollContainer: DraggableElement;\r\n  unsubscribers: Array<() => void>;\r\n  onComplete: () => void;\r\n  onInsertPlaceholder: () => void;\r\n};\r\n\r\nconst Context = createContext<DragDropContextValue>(null);\r\n\r\nconst inititalState: ContextState = {\r\n  isDragging: false,\r\n  isIntersected: false,\r\n  contextID: null,\r\n  activeDroppableID: null,\r\n  activeDroppableGroupID: null,\r\n  activeDraggableID: null,\r\n  nodeWidth: null,\r\n  nodeHeight: null,\r\n  scrollContainer: null,\r\n  unsubscribers: [],\r\n  onComplete: null,\r\n  onInsertPlaceholder: null,\r\n};\r\n\r\nlet nextContextID = 0;\r\n\r\nfunction getNextContextID() {\r\n  return ++nextContextID;\r\n}\r\n\r\nfunction reducer(state: ContextState, action: { value: Partial<ContextState> }) {\r\n  return {\r\n    ...state,\r\n    ...action.value,\r\n  };\r\n}\r\n\r\nfunction useDragDropContext() {\r\n  const value = useContext(Context);\r\n\r\n  return value;\r\n}\r\n\r\ntype CallbackShared = {\r\n  draggableID: ID;\r\n  droppableID: ID;\r\n  droppableGroupID: ID;\r\n  targetNode: DraggableElement;\r\n};\r\n\r\nexport type OnDragStartOptions = {} & CallbackShared;\r\n\r\nexport type OnDragOverOptions = {\r\n  nearestNode: DraggableElement | null;\r\n} & CallbackShared;\r\n\r\nexport type OnDragEndOptions = {\r\n  sourceIdx: number;\r\n  destinationIdx: number;\r\n  isMoving: boolean;\r\n} & CallbackShared;\r\n\r\nexport { DragDropContext, useDragDropContext };\r\n","import React, { useRef, useLayoutEffect, useEffect, memo, useMemo, createContext, useContext } from 'react';\r\n\r\nimport type { ID, Direction, Pointer, DraggableElement } from './types';\r\nimport { useDragDropContext, type DragDropContextValue } from './context';\r\nimport {\r\n  CONTEXT_ID_ATTR,\r\n  DROPPABLE_ID_ATTR,\r\n  setStyles,\r\n  removeStyles,\r\n  getItemNodes,\r\n  detectIsActiveDraggableNode,\r\n  getActiveDraggableNode,\r\n  getActiveDroppableNode,\r\n  getScrollContainerFromContainer,\r\n  safeNumber,\r\n  getThreshold,\r\n  debounce,\r\n  createPointer,\r\n} from './utils';\r\n\r\nexport type DroppableProps = {\r\n  direction: Direction;\r\n  droppableID: ID;\r\n  droppableGroupID: ID;\r\n  transitionTimeout?: number;\r\n  transitionTimingFn?: string;\r\n  disabled?: boolean;\r\n  debounceTimeout?: number;\r\n  children: (options: DroppableChildrenOptions) => React.ReactElement;\r\n};\r\n\r\nconst Droppable: React.FC<DroppableProps> = props => {\r\n  const { droppableID } = props;\r\n  const dragDropContext = useDragDropContext();\r\n  const { state } = dragDropContext;\r\n  const { isDragging, activeDroppableID } = state;\r\n  const isActive = droppableID === activeDroppableID;\r\n  const updatingKey = `${isDragging}:${isActive}`;\r\n\r\n  return <DroppableInner {...props} updatingKey={updatingKey} dragDropContext={dragDropContext} />;\r\n};\r\n\r\ntype DroppableInnerProps = {\r\n  updatingKey: string;\r\n  dragDropContext: DragDropContextValue;\r\n} & DroppableProps;\r\n\r\nconst DroppableInner: React.FC<DroppableInnerProps> = memo(\r\n  props => {\r\n    const {\r\n      droppableID,\r\n      droppableGroupID,\r\n      direction,\r\n      transitionTimeout,\r\n      transitionTimingFn,\r\n      debounceTimeout,\r\n      disabled,\r\n      dragDropContext,\r\n      children,\r\n    } = props;\r\n    const { state, mergeState, resetState, onDragOver, onDragEnd } = dragDropContext;\r\n    const {\r\n      isDragging: isSomeDragging,\r\n      contextID,\r\n      nodeWidth,\r\n      nodeHeight,\r\n      activeDraggableID,\r\n      activeDroppableID,\r\n      activeDroppableGroupID,\r\n      isIntersected,\r\n      unsubscribers,\r\n      onInsertPlaceholder,\r\n    } = state;\r\n    const isActiveGroup = !disabled && droppableGroupID === activeDroppableGroupID;\r\n    const isActive = isActiveGroup && droppableID === activeDroppableID;\r\n    const isDragging = isSomeDragging && isActive;\r\n    const rootRef = useRef<DraggableElement>(null);\r\n    const nearestNodeRef = useRef<DraggableElement>(null);\r\n    const scope = useMemo<DroppableScope>(() => ({ removePlaceholder: () => {} }), []);\r\n    const nodes = useMemo(() => (rootRef.current ? getItemNodes(contextID, droppableID) : []), [isDragging]);\r\n\r\n    const handleDragEnd = (targetNode: DraggableElement) => {\r\n      const sourceIdx = nodes.findIndex(x => detectIsActiveDraggableNode(x, activeDraggableID));\r\n      const targetNodeRect = targetNode.getBoundingClientRect();\r\n      const isMoving = sourceIdx === -1;\r\n      let destinationIdx = 0;\r\n\r\n      for (const node of nodes) {\r\n        const nodeRect = node.getBoundingClientRect();\r\n        const map: Record<DroppableProps['direction'], () => void> = {\r\n          vertical: () => {\r\n            if (safeNumber(targetNodeRect.top + targetNodeRect.height) > safeNumber(nodeRect.top + nodeRect.height)) {\r\n              destinationIdx++;\r\n            }\r\n          },\r\n          horizontal: () => {\r\n            if (safeNumber(targetNodeRect.left + targetNodeRect.width) > safeNumber(nodeRect.left + nodeRect.width)) {\r\n              destinationIdx++;\r\n            }\r\n          },\r\n        };\r\n\r\n        map[direction]();\r\n      }\r\n\r\n      setTimeout(() => {\r\n        scope.removePlaceholder(true);\r\n        nodes.forEach(x => removeStyles(x, ['transition', 'transform']));\r\n        resetState();\r\n      });\r\n\r\n      onDragEnd({\r\n        draggableID: activeDraggableID,\r\n        droppableID,\r\n        droppableGroupID,\r\n        sourceIdx,\r\n        destinationIdx,\r\n        isMoving,\r\n        targetNode,\r\n      });\r\n    };\r\n\r\n    useBackwardTransitionEffect({\r\n      isDragging,\r\n      isIntersected,\r\n      activeDraggableID,\r\n      nodes,\r\n      transitionTimeout,\r\n    });\r\n\r\n    useIntersectionEffect({\r\n      contextID,\r\n      activeDraggableID,\r\n      activeDroppableID,\r\n      isActiveGroup,\r\n      isActive,\r\n      isSomeDragging,\r\n      debounceTimeout,\r\n      rootNode: rootRef.current,\r\n      unsubscribers,\r\n      onIntersect: (targetNode, pointer) => {\r\n        mergeState({\r\n          activeDroppableID: droppableID,\r\n          isIntersected: true,\r\n          scrollContainer: getScrollContainerFromContainer(rootRef.current),\r\n          onInsertPlaceholder: () => {\r\n            transformNodesByTarget({\r\n              direction,\r\n              targetNode,\r\n              nodeWidth,\r\n              nodeHeight,\r\n              pointer,\r\n              activeDraggableID,\r\n              transitionTimeout,\r\n              transitionTimingFn,\r\n              nodes: getItemNodes(contextID, droppableID),\r\n              onMarkNearestNode: (nearestNode, targetNode) => {\r\n                nearestNodeRef.current = nearestNode || null;\r\n                onDragOver({\r\n                  draggableID: activeDraggableID,\r\n                  droppableID: activeDroppableID,\r\n                  droppableGroupID: activeDroppableGroupID,\r\n                  nearestNode,\r\n                  targetNode,\r\n                });\r\n              },\r\n            });\r\n          },\r\n        });\r\n      },\r\n    });\r\n\r\n    usePlaceholderEffect({\r\n      isDragging,\r\n      nodeWidth,\r\n      nodeHeight,\r\n      container: rootRef.current,\r\n      scope,\r\n      isIntersected,\r\n      transitionTimeout,\r\n      transitionTimingFn,\r\n      onInsertPlaceholder,\r\n    });\r\n\r\n    useDragMoveEffect({\r\n      isDragging,\r\n      unsubscribers,\r\n      transformNodesByTargetOptions: {\r\n        direction,\r\n        nodes,\r\n        activeDraggableID,\r\n        nodeHeight,\r\n        nodeWidth,\r\n        transitionTimeout,\r\n        transitionTimingFn,\r\n        onMarkNearestNode: (nearestNode, targetNode) => {\r\n          nearestNodeRef.current = nearestNode || null;\r\n          onDragOver({\r\n            draggableID: activeDraggableID,\r\n            droppableID: activeDroppableID,\r\n            droppableGroupID: activeDroppableGroupID,\r\n            nearestNode,\r\n            targetNode,\r\n          });\r\n        },\r\n      },\r\n    });\r\n\r\n    useDragEndEffect({\r\n      direction,\r\n      isDragging,\r\n      contextID,\r\n      activeDraggableID,\r\n      activeDroppableID,\r\n      nearestNodeRef,\r\n      transitionTimeout,\r\n      transitionTimingFn,\r\n      unsubscribers,\r\n      onDragEnd: handleDragEnd,\r\n    });\r\n\r\n    const contextValue = useMemo<DroppableContextValue>(\r\n      () => ({\r\n        direction,\r\n        droppableID,\r\n        droppableGroupID,\r\n        disabled,\r\n      }),\r\n      [direction, droppableID, droppableGroupID, disabled],\r\n    );\r\n\r\n    return (\r\n      <DroppableContext.Provider value={contextValue}>\r\n        {children({\r\n          ref: rootRef,\r\n          [CONTEXT_ID_ATTR]: contextID,\r\n          [DROPPABLE_ID_ATTR]: droppableID,\r\n          snapshot: {\r\n            isDragging,\r\n          },\r\n          onDragStart: defaultHandleDragStart,\r\n        })}\r\n      </DroppableContext.Provider>\r\n    );\r\n  },\r\n  (prevProps, nextProps) => prevProps.updatingKey === nextProps.updatingKey,\r\n);\r\n\r\nDroppable.defaultProps = {\r\n  transitionTimeout: 200,\r\n  transitionTimingFn: 'ease-in-out',\r\n  debounceTimeout: 0,\r\n};\r\n\r\ntype DroppableScope = {\r\n  removePlaceholder: (fromDragEnd?: boolean) => void;\r\n};\r\n\r\ntype DroppableContextValue = {} & Pick<DroppableProps, 'direction' | 'droppableID' | 'droppableGroupID' | 'disabled'>;\r\n\r\nconst DroppableContext = createContext<DroppableContextValue>(null);\r\n\r\nfunction useDroppableContext() {\r\n  return useContext(DroppableContext);\r\n}\r\n\r\nconst defaultHandleDragStart = (e: React.MouseEvent) => e.preventDefault();\r\n\r\nexport type DroppableChildrenOptions = {\r\n  ref: React.Ref<any>;\r\n  [CONTEXT_ID_ATTR]: number;\r\n  [DROPPABLE_ID_ATTR]: ID;\r\n  snapshot: {\r\n    isDragging: boolean;\r\n  };\r\n  onDragStart: React.DragEventHandler;\r\n};\r\n\r\ntype UseBackwardTransitionEffectOptions = {\r\n  isDragging: boolean;\r\n  isIntersected: boolean;\r\n  activeDraggableID: ID;\r\n  transitionTimeout: number;\r\n  nodes: Array<DraggableElement>;\r\n};\r\n\r\nfunction useBackwardTransitionEffect(options: UseBackwardTransitionEffectOptions) {\r\n  const { isDragging, isIntersected, activeDraggableID, transitionTimeout, nodes } = options;\r\n\r\n  useEffect(() => {\r\n    if (isDragging || !isIntersected || nodes.length === 0) return;\r\n\r\n    for (const node of nodes) {\r\n      if (detectIsActiveDraggableNode(node, activeDraggableID)) continue;\r\n\r\n      setStyles(node, {\r\n        transform: `translate3D(0, 0, 0)`,\r\n      });\r\n\r\n      setTimeout(() => {\r\n        removeStyles(node, ['transition', 'transform']);\r\n      }, transitionTimeout);\r\n    }\r\n  }, [isDragging]);\r\n}\r\n\r\ntype UseIntersectionEffectOptions = {\r\n  isSomeDragging: boolean;\r\n  isActiveGroup: boolean;\r\n  isActive: boolean;\r\n  rootNode: DraggableElement;\r\n  contextID: number;\r\n  activeDroppableID: ID;\r\n  activeDraggableID: ID;\r\n  unsubscribers: Array<() => void>;\r\n  onIntersect: (targetNode: DraggableElement, pointer: Pointer) => void;\r\n} & Required<Pick<DroppableProps, 'debounceTimeout'>>;\r\n\r\nfunction useIntersectionEffect(options: UseIntersectionEffectOptions) {\r\n  const {\r\n    isSomeDragging,\r\n    isActiveGroup,\r\n    isActive,\r\n    rootNode,\r\n    contextID,\r\n    activeDroppableID,\r\n    activeDraggableID,\r\n    debounceTimeout,\r\n    unsubscribers,\r\n    onIntersect,\r\n  } = options;\r\n\r\n  useEffect(() => {\r\n    if (!isSomeDragging) return;\r\n    const handleDragMove = debounce((e: PointerEvent) => {\r\n      if (e.target instanceof Document) return;\r\n      if (!isSomeDragging) return;\r\n      if (!isActiveGroup) return;\r\n      if (isActive) return;\r\n      const draggableNode = getActiveDraggableNode(contextID, activeDraggableID);\r\n      const droppableRect = rootNode.getBoundingClientRect();\r\n      const draggableRect = draggableNode.getBoundingClientRect();\r\n      const draggableRectTop = safeNumber(draggableRect.top);\r\n      const draggableRectLeft = safeNumber(draggableRect.left);\r\n      const droppableRectTop = safeNumber(droppableRect.top);\r\n      const droppableRectLeft = safeNumber(droppableRect.left);\r\n      const droppableRectHeight = safeNumber(droppableRect.height);\r\n      const droppableRectWidth = safeNumber(droppableRect.width);\r\n      const isYaxesIntersected =\r\n        draggableRectTop > droppableRectTop && draggableRectTop < droppableRectTop + droppableRectHeight;\r\n      const isXaxesIntersected =\r\n        draggableRectLeft > droppableRectLeft && draggableRectLeft < droppableRectLeft + droppableRectWidth;\r\n\r\n      if (isYaxesIntersected && isXaxesIntersected) {\r\n        const targetNode = e.target as DraggableElement;\r\n        const pointer = createPointer(e);\r\n\r\n        onIntersect(targetNode, pointer);\r\n      }\r\n    }, debounceTimeout);\r\n\r\n    document.addEventListener('pointermove', handleDragMove);\r\n\r\n    const unsubscribe = () => {\r\n      document.removeEventListener('pointermove', handleDragMove);\r\n    };\r\n\r\n    unsubscribers.push(unsubscribe);\r\n\r\n    return () => performUnsubscribers(unsubscribe, unsubscribers);\r\n  }, [isSomeDragging, activeDroppableID, rootNode]);\r\n}\r\n\r\ntype UsePlaceholderEffectOptions = {\r\n  isDragging: boolean;\r\n  nodeWidth: number;\r\n  nodeHeight: number;\r\n  container: DraggableElement;\r\n  scope: DroppableScope;\r\n  isIntersected: boolean;\r\n  onInsertPlaceholder: () => void;\r\n} & Required<Pick<DroppableProps, 'transitionTimeout' | 'transitionTimingFn'>>;\r\n\r\nfunction usePlaceholderEffect(options: UsePlaceholderEffectOptions) {\r\n  const {\r\n    isDragging,\r\n    nodeWidth,\r\n    nodeHeight,\r\n    container,\r\n    scope,\r\n    isIntersected,\r\n    transitionTimeout,\r\n    transitionTimingFn,\r\n    onInsertPlaceholder,\r\n  } = options;\r\n\r\n  useLayoutEffect(() => {\r\n    if (isDragging) {\r\n      const placeholder = document.createElement('div');\r\n      const inner = document.createElement('div');\r\n      const transition = `max-width ${transitionTimeout}ms ${transitionTimingFn}, max-height ${transitionTimeout}ms ${transitionTimingFn}`;\r\n\r\n      placeholder.appendChild(inner);\r\n      container.appendChild(placeholder);\r\n\r\n      setStyles(placeholder, {\r\n        flex: `0 0 auto`,\r\n      });\r\n\r\n      if (isIntersected) {\r\n        setStyles(placeholder, {\r\n          maxWidth: 0,\r\n          maxHeight: 0,\r\n        });\r\n\r\n        setStyles(inner, {\r\n          width: `${nodeWidth}px`,\r\n          height: `${nodeHeight}px`,\r\n        });\r\n\r\n        requestAnimationFrame(() => {\r\n          setStyles(placeholder, {\r\n            transition,\r\n            maxWidth: `${nodeWidth}px`,\r\n            maxHeight: `${nodeHeight}px`,\r\n          });\r\n        });\r\n      } else {\r\n        setStyles(placeholder, {\r\n          width: `${nodeWidth}px`,\r\n          height: `${nodeHeight}px`,\r\n        });\r\n      }\r\n\r\n      scope.removePlaceholder = (fromDragEnd: boolean) => {\r\n        if (fromDragEnd) {\r\n          placeholder.parentElement.removeChild(placeholder);\r\n        } else {\r\n          setStyles(placeholder, {\r\n            transition,\r\n            maxWidth: `${nodeWidth}px`,\r\n            maxHeight: `${nodeHeight}px`,\r\n          });\r\n\r\n          requestAnimationFrame(() => {\r\n            setStyles(placeholder, {\r\n              maxWidth: 0,\r\n              maxHeight: 0,\r\n            });\r\n\r\n            setTimeout(() => {\r\n              placeholder.parentElement.removeChild(placeholder);\r\n            }, transitionTimeout);\r\n          });\r\n        }\r\n\r\n        scope.removePlaceholder = () => {};\r\n      };\r\n\r\n      onInsertPlaceholder();\r\n    }\r\n\r\n    return () => scope.removePlaceholder();\r\n  }, [isDragging]);\r\n}\r\n\r\ntype UseDragMoveEffectOptions = {\r\n  isDragging: boolean;\r\n  unsubscribers: Array<() => void>;\r\n  transformNodesByTargetOptions: Omit<TransformNodesByTargetOptions, 'targetNode' | 'pointer'>;\r\n};\r\n\r\nfunction useDragMoveEffect(options: UseDragMoveEffectOptions) {\r\n  const { isDragging, unsubscribers, transformNodesByTargetOptions } = options;\r\n  const scope = useMemo(() => ({ options: null }), []);\r\n\r\n  scope.options = transformNodesByTargetOptions;\r\n\r\n  useLayoutEffect(() => {\r\n    if (!isDragging) return;\r\n\r\n    const handleDragMove = debounce((e: PointerEvent) => {\r\n      if (e.target instanceof Document) return;\r\n      const targetNode = e.target as DraggableElement;\r\n      const pointer = createPointer(e);\r\n\r\n      transformNodesByTarget({ ...scope.options, targetNode, pointer });\r\n    });\r\n\r\n    document.addEventListener('pointermove', handleDragMove);\r\n\r\n    const unsubscribe = () => {\r\n      document.removeEventListener('pointermove', handleDragMove);\r\n    };\r\n\r\n    unsubscribers.push(unsubscribe);\r\n\r\n    return () => performUnsubscribers(unsubscribe, unsubscribers);\r\n  }, [isDragging]);\r\n}\r\n\r\ntype UseDragEndEffectOptions = {\r\n  direction: Direction;\r\n  isDragging: boolean;\r\n  contextID: number;\r\n  activeDraggableID: ID;\r\n  activeDroppableID: ID;\r\n  nearestNodeRef: React.MutableRefObject<DraggableElement>;\r\n  unsubscribers: Array<() => void>;\r\n  onDragEnd: (node: DraggableElement) => void;\r\n} & Required<Pick<DroppableProps, 'transitionTimeout' | 'transitionTimingFn'>>;\r\n\r\nfunction useDragEndEffect(options: UseDragEndEffectOptions) {\r\n  const {\r\n    direction,\r\n    isDragging,\r\n    contextID,\r\n    activeDraggableID,\r\n    activeDroppableID,\r\n    nearestNodeRef,\r\n    transitionTimeout,\r\n    transitionTimingFn,\r\n    unsubscribers,\r\n    onDragEnd,\r\n  } = options;\r\n\r\n  useLayoutEffect(() => {\r\n    if (!isDragging) return;\r\n\r\n    const handleDragEnd = () => {\r\n      unsubscribers.forEach(fn => fn());\r\n      unsubscribers.splice(0, unsubscribers.length);\r\n\r\n      const nearestNode = nearestNodeRef.current || null;\r\n      const hasTransform = nearestNode && window.getComputedStyle(nearestNode).transform !== 'none';\r\n\r\n      const applyTransition = () => {\r\n        const targetNode = getActiveDraggableNode(contextID, activeDraggableID);\r\n\r\n        applyTargetNodeTransition({\r\n          direction,\r\n          contextID,\r\n          activeDroppableID,\r\n          targetNode,\r\n          nearestNode,\r\n          transitionTimeout,\r\n          transitionTimingFn,\r\n          onComplete: onDragEnd,\r\n        });\r\n      };\r\n\r\n      if (nearestNode && hasTransform) {\r\n        setTimeout(() => {\r\n          applyTransition();\r\n        }, transitionTimeout);\r\n      } else {\r\n        applyTransition();\r\n      }\r\n    };\r\n\r\n    document.addEventListener('pointerup', handleDragEnd);\r\n\r\n    const unsubscribe = () => {\r\n      document.removeEventListener('pointerup', handleDragEnd);\r\n    };\r\n\r\n    unsubscribers.push(unsubscribe);\r\n\r\n    return () => performUnsubscribers(unsubscribe, unsubscribers);\r\n  }, [isDragging]);\r\n}\r\n\r\ntype ApplyTargetNodeTransitionOptions = {\r\n  direction: Direction;\r\n  contextID: number;\r\n  activeDroppableID: ID;\r\n  targetNode: DraggableElement;\r\n  nearestNode: DraggableElement | null;\r\n  onComplete: (targetNode: DraggableElement) => void;\r\n} & Required<Pick<DroppableProps, 'transitionTimeout' | 'transitionTimingFn'>>;\r\n\r\nconst applyTargetNodeTransition = (options: ApplyTargetNodeTransitionOptions) => {\r\n  const {\r\n    direction,\r\n    contextID,\r\n    activeDroppableID,\r\n    targetNode,\r\n    nearestNode,\r\n    transitionTimeout,\r\n    transitionTimingFn,\r\n    onComplete,\r\n  } = options;\r\n  const targetNodeStyle = window.getComputedStyle(targetNode);\r\n  const hasTransform = targetNodeStyle.transform !== 'none';\r\n  const isVertical = direction === 'vertical';\r\n  const { droppableTop, droppableLeft } = getDroppableContainerOffsets();\r\n\r\n  function getDroppableContainerOffsets() {\r\n    const droppableNode = getActiveDroppableNode(contextID, activeDroppableID);\r\n    const { top, left } = droppableNode.getBoundingClientRect();\r\n    const style = window.getComputedStyle(droppableNode);\r\n    const paddingTop = parseInt(style.paddingTop, 10);\r\n    const paddingLeft = parseInt(style.paddingLeft, 10);\r\n    const droppableTop = safeNumber(top + paddingTop);\r\n    const droppableLeft = safeNumber(left + paddingLeft);\r\n\r\n    return { droppableTop, droppableLeft };\r\n  }\r\n\r\n  const getVerticalDirectionOffset = () => {\r\n    if (nearestNode) {\r\n      const { bottom } = nearestNode.getBoundingClientRect();\r\n      const marginTop = parseInt(targetNodeStyle.marginTop, 10);\r\n\r\n      return safeNumber(bottom + marginTop);\r\n    }\r\n\r\n    return droppableTop;\r\n  };\r\n\r\n  const getHorizontalDirectionOffset = () => {\r\n    if (nearestNode) {\r\n      const { left, width } = nearestNode.getBoundingClientRect();\r\n      const marginLeft = parseInt(targetNodeStyle.marginLeft, 10);\r\n\r\n      return safeNumber(left + width + marginLeft);\r\n    }\r\n\r\n    return droppableTop;\r\n  };\r\n\r\n  const offset = isVertical ? getVerticalDirectionOffset() : getHorizontalDirectionOffset();\r\n\r\n  if (hasTransform) {\r\n    const styles = {\r\n      transition: `transform ${transitionTimeout}ms ${transitionTimingFn}, top ${transitionTimeout}ms ${transitionTimingFn}, left ${transitionTimeout}ms ${transitionTimingFn}`,\r\n      transform: `translate3D(0, 0, 0)`,\r\n      top: undefined,\r\n      left: undefined,\r\n    };\r\n\r\n    if (isVertical) {\r\n      styles.top = `${offset}px`;\r\n      styles.left = `${droppableLeft}px`;\r\n    } else {\r\n      styles.top = `${droppableTop}px`;\r\n      styles.left = `${offset}px`;\r\n    }\r\n\r\n    setStyles(targetNode, styles);\r\n\r\n    setTimeout(() => {\r\n      onComplete(targetNode);\r\n    }, transitionTimeout);\r\n  } else {\r\n    onComplete(targetNode);\r\n  }\r\n};\r\n\r\ntype TransformNodesByTargetOptions = {\r\n  direction: Direction;\r\n  targetNode: DraggableElement;\r\n  pointer: Pointer;\r\n  nodes: Array<DraggableElement>;\r\n  activeDraggableID: ID;\r\n  nodeHeight: number;\r\n  nodeWidth: number;\r\n  onMarkNearestNode?: (nearestNode: DraggableElement, targetNode: DraggableElement) => void;\r\n} & Pick<DroppableProps, 'transitionTimeout' | 'transitionTimingFn'>;\r\n\r\nconst transformNodesByTarget = (options: TransformNodesByTargetOptions) => {\r\n  const {\r\n    direction,\r\n    targetNode,\r\n    pointer,\r\n    nodes,\r\n    activeDraggableID,\r\n    nodeHeight,\r\n    nodeWidth,\r\n    transitionTimeout = 0,\r\n    transitionTimingFn = '',\r\n    onMarkNearestNode = () => {},\r\n  } = options;\r\n  const targetRect = targetNode.getBoundingClientRect();\r\n  let nearestNode: DraggableElement = null;\r\n  let minimalDiff = Infinity;\r\n  const fns: Array<() => void> = [];\r\n\r\n  for (const node of nodes) {\r\n    if (detectIsActiveDraggableNode(node, activeDraggableID)) continue;\r\n    const rect = node.getBoundingClientRect();\r\n    const top = safeNumber(rect.top);\r\n    const left = safeNumber(rect.left);\r\n    const { thresholdY, thresholdX } = getThreshold(targetRect, pointer);\r\n    const map: Record<Direction, () => void> = {\r\n      vertical: () => {\r\n        if (thresholdY <= top || thresholdY - top === 1) {\r\n          setStyles(node, {\r\n            transition: `transform ${transitionTimeout}ms ${transitionTimingFn}`,\r\n            transform: `translate3d(0px, ${nodeHeight}px, 0px)`,\r\n          });\r\n        } else {\r\n          removeStyles(node, ['transform']);\r\n\r\n          const diff = safeNumber(thresholdY - top);\r\n\r\n          if (diff < minimalDiff) {\r\n            minimalDiff = diff;\r\n            nearestNode = node;\r\n          }\r\n        }\r\n      },\r\n      horizontal: () => {\r\n        if (thresholdX <= left || thresholdX - left === 1) {\r\n          setStyles(node, {\r\n            transition: `transform ${transitionTimeout}ms ${transitionTimingFn}`,\r\n            transform: `translate3d(${nodeWidth}px, 0px, 0px)`,\r\n          });\r\n        } else {\r\n          removeStyles(node, ['transform']);\r\n\r\n          const diff = safeNumber(thresholdX - left);\r\n\r\n          if (diff < minimalDiff) {\r\n            minimalDiff = diff;\r\n            nearestNode = node;\r\n          }\r\n        }\r\n      },\r\n    };\r\n\r\n    fns.push(map[direction]);\r\n  }\r\n\r\n  // read first getBoundingClientRect in loop, then change styles to improve performance\r\n  fns.forEach(fn => fn());\r\n\r\n  onMarkNearestNode(nearestNode, targetNode);\r\n};\r\n\r\nfunction performUnsubscribers(unsubscribe: () => void, unsubscribers: Array<() => void>) {\r\n  const idx = unsubscribers.findIndex(x => x === unsubscribe);\r\n\r\n  if (idx !== -1) {\r\n    unsubscribe();\r\n    unsubscribers.splice(idx, 1);\r\n  }\r\n}\r\n\r\nexport { Droppable, useDroppableContext, transformNodesByTarget };\r\n","import React, { useRef, useMemo, useLayoutEffect, memo } from 'react';\r\n\r\nimport type { ID, Pointer, Coordinates, DraggableElement } from './types';\r\nimport { useDragDropContext, type DragDropContextValue } from './context';\r\nimport { useDroppableContext, transformNodesByTarget } from './droppable';\r\nimport {\r\n  CONTEXT_ID_ATTR,\r\n  DROPPABLE_ID_ATTR,\r\n  DRAGGABLE_ID_ATTR,\r\n  DRAGGABLE_HANDLER_ATTR,\r\n  setStyles,\r\n  removeStyles,\r\n  getScrollContainer,\r\n  getNodeSize,\r\n  getItemNodes,\r\n  createPointer,\r\n} from './utils';\r\n\r\nexport type DraggableProps = {\r\n  draggableID: ID;\r\n  children: (options: DraggableChildrenOptions) => React.ReactElement;\r\n};\r\n\r\nconst Draggable: React.FC<DraggableProps> = props => {\r\n  const { draggableID } = props;\r\n  const dragDropContext = useDragDropContext();\r\n  const { state } = dragDropContext;\r\n  const { isDragging, activeDraggableID } = state;\r\n  const isActive = draggableID === activeDraggableID;\r\n  const updatingKey = `${isDragging}:${isActive}`;\r\n\r\n  return <DraggableInner {...props} updatingKey={updatingKey} dragDropContext={dragDropContext} />;\r\n};\r\n\r\ntype DraggableInnerProps = {\r\n  updatingKey: string;\r\n  dragDropContext: DragDropContextValue;\r\n} & DraggableProps;\r\n\r\nconst DraggableInner: React.FC<DraggableInnerProps> = memo(\r\n  props => {\r\n    const { draggableID, dragDropContext, children } = props;\r\n    const { state, mergeState, onDragStart } = dragDropContext;\r\n    const { droppableID, droppableGroupID, direction, disabled } = useDroppableContext();\r\n    const { contextID, scrollContainer } = state;\r\n    const rootRef = useRef<DraggableElement>(null);\r\n    const isActive = state.isDragging && state.activeDraggableID === draggableID;\r\n    const scope = useMemo<DraggableScope>(() => ({ removeSensor: null, scrollContainer: null }), []);\r\n\r\n    scope.scrollContainer = scrollContainer;\r\n\r\n    useLayoutEffect(() => () => scope.removeSensor && scope.removeSensor(), []);\r\n\r\n    const handleStartEvent = (startEvent: React.PointerEvent) => {\r\n      if (disabled || !startEvent.isPrimary || startEvent.buttons !== 1 || state.onComplete) return;\r\n      const targetNode = rootRef.current;\r\n      const targetRect = targetNode.getBoundingClientRect();\r\n      const scrollContainer = getScrollContainer(targetNode);\r\n      const { nodeWidth, nodeHeight } = getNodeSize(targetNode, targetRect);\r\n      const startPointer = createPointer(startEvent.nativeEvent);\r\n\r\n      onDragStart({\r\n        targetNode,\r\n        draggableID,\r\n        droppableID,\r\n        droppableGroupID,\r\n      });\r\n\r\n      const handleDragMove = (moveEvent: PointerEvent) => {\r\n        if (moveEvent.target instanceof Document) return;\r\n        const movePointer = createPointer(moveEvent);\r\n\r\n        syncMove({\r\n          targetNode,\r\n          startPointer,\r\n          movePointer,\r\n          scrollContainer: scope.scrollContainer,\r\n        });\r\n      };\r\n\r\n      const removeSensor = () => {\r\n        document.removeEventListener('pointermove', handleDragMove);\r\n      };\r\n\r\n      const handleComplete = () => removeNodeStyles(targetNode);\r\n\r\n      const handleInsertPlaceholder = () => {\r\n        transformNodesByTarget({\r\n          direction,\r\n          targetNode,\r\n          nodeWidth,\r\n          nodeHeight,\r\n          pointer: startPointer,\r\n          activeDraggableID: draggableID,\r\n          nodes: getItemNodes(contextID, droppableID),\r\n        });\r\n      };\r\n\r\n      setNodeDragStyles(targetNode, targetRect);\r\n      mergeState({\r\n        isDragging: true,\r\n        activeDroppableID: droppableID,\r\n        activeDroppableGroupID: droppableGroupID,\r\n        activeDraggableID: draggableID,\r\n        nodeWidth,\r\n        nodeHeight,\r\n        scrollContainer,\r\n        unsubscribers: [removeSensor],\r\n        onComplete: handleComplete,\r\n        onInsertPlaceholder: handleInsertPlaceholder,\r\n      });\r\n\r\n      scope.removeSensor = () => {\r\n        removeSensor();\r\n        scope.removeSensor = null;\r\n      };\r\n      document.addEventListener('pointermove', handleDragMove);\r\n    };\r\n\r\n    return children({\r\n      rootProps: {\r\n        ref: rootRef,\r\n        draggable: false,\r\n        [CONTEXT_ID_ATTR]: contextID,\r\n        [DROPPABLE_ID_ATTR]: droppableID,\r\n        [DRAGGABLE_ID_ATTR]: draggableID,\r\n      },\r\n      draggableProps: {\r\n        [DRAGGABLE_HANDLER_ATTR]: true,\r\n        onPointerDown: handleStartEvent,\r\n      },\r\n      snapshot: {\r\n        isDragging: isActive,\r\n      },\r\n    });\r\n  },\r\n  (prevProps, nextProps) => prevProps.updatingKey === nextProps.updatingKey,\r\n);\r\n\r\nexport type DraggableChildrenOptions = {\r\n  rootProps: {\r\n    ref: React.Ref<any>;\r\n    draggable: false;\r\n    [CONTEXT_ID_ATTR]: number;\r\n    [DROPPABLE_ID_ATTR]: ID;\r\n    [DRAGGABLE_ID_ATTR]: ID;\r\n  };\r\n  draggableProps: {\r\n    [DRAGGABLE_HANDLER_ATTR]: true;\r\n    onPointerDown: (e: React.PointerEvent) => void;\r\n  };\r\n  snapshot: {\r\n    isDragging: boolean;\r\n  };\r\n};\r\n\r\ntype DraggableScope = {\r\n  removeSensor: () => void;\r\n  scrollContainer: DraggableElement;\r\n};\r\n\r\ntype SyncMoveOptions = {\r\n  targetNode: DraggableElement;\r\n  startPointer: Pointer;\r\n  movePointer: Pointer;\r\n  scrollContainer: DraggableElement;\r\n};\r\n\r\nfunction syncMove(options: SyncMoveOptions) {\r\n  const { targetNode, startPointer, movePointer, scrollContainer } = options;\r\n  const { x, y } = getCoordinates({ movePointer, startPointer });\r\n\r\n  transformNodePosition(targetNode, { x, y });\r\n  requestAnimationFrame(() => syncScroll({ movePointer, scrollContainer }));\r\n}\r\n\r\ntype SyncScrollOptions = {\r\n  movePointer: Pointer;\r\n  scrollContainer: DraggableElement;\r\n};\r\n\r\nfunction syncScroll(options: SyncScrollOptions) {\r\n  const { movePointer, scrollContainer } = options;\r\n  const isRoot = scrollContainer === document.body;\r\n  const element = isRoot ? window : scrollContainer;\r\n  const velocity = 1000;\r\n  const delta = 50;\r\n  const isTop = window.innerHeight - movePointer.clientY <= delta;\r\n  const isBottom = movePointer.clientY <= delta;\r\n  const isRight = window.innerWidth - movePointer.clientX <= delta;\r\n  const isLeft = movePointer.clientX <= delta;\r\n\r\n  if (isTop || isBottom || isRight || isLeft) {\r\n    const dy = isRoot ? window.scrollY : scrollContainer.scrollTop;\r\n    const dx = isRoot ? window.scrollX : scrollContainer.scrollLeft;\r\n\r\n    element.scroll({\r\n      top: isTop ? dy + velocity : isBottom ? dy - velocity : dy,\r\n      left: isRight ? dx + velocity : isLeft ? dx - velocity : dx,\r\n      behavior: 'smooth',\r\n    });\r\n  }\r\n}\r\n\r\ntype GetCoordinatesOptions = {\r\n  movePointer: Pointer;\r\n  startPointer: Pointer;\r\n};\r\n\r\nfunction getCoordinates(options: GetCoordinatesOptions): Coordinates {\r\n  const { movePointer, startPointer } = options;\r\n  const x = movePointer.clientX - startPointer.clientX;\r\n  const y = movePointer.clientY - startPointer.clientY;\r\n\r\n  return { x, y };\r\n}\r\n\r\nfunction setNodeDragStyles(node: DraggableElement, rect: DOMRect) {\r\n  const style = window.getComputedStyle(node);\r\n  const marginTop = parseInt(style.marginTop);\r\n  const marginLeft = parseInt(style.marginLeft);\r\n  const top = rect.top - marginTop;\r\n  const left = rect.left - marginLeft;\r\n\r\n  setStyles(node, {\r\n    position: 'fixed',\r\n    zIndex: '100000',\r\n    top: `${top}px`,\r\n    left: `${left}px`,\r\n    width: `${rect.width}px`,\r\n    height: `${rect.height}px`,\r\n    transformOrigin: '0 0',\r\n    transition: 'none',\r\n  });\r\n}\r\n\r\nfunction transformNodePosition(node: DraggableElement, { x, y }: Coordinates) {\r\n  setStyles(node, {\r\n    transform: `translate3D(${x}px, ${y}px, 0px)`,\r\n  });\r\n}\r\n\r\nfunction removeNodeStyles(node: DraggableElement) {\r\n  removeStyles(node, [\r\n    'position',\r\n    'top',\r\n    'left',\r\n    'z-index',\r\n    'width',\r\n    'height',\r\n    'transform',\r\n    'transition',\r\n    'transform-origin',\r\n  ]);\r\n}\r\n\r\nexport { Draggable };\r\n","import { type OnDragEndOptions } from './context';\r\nimport { createBooleanMap } from './utils';\r\nimport type { ID } from './types';\r\n\r\ntype ReorderOptions<T> = {\r\n  items: Array<T>;\r\n  getDroppableID: (x: T) => ID;\r\n  getDraggableID: (x: T) => ID;\r\n} & OnDragEndOptions;\r\n\r\nfunction reorder<T>(options: ReorderOptions<T>) {\r\n  const { items, sourceIdx, destinationIdx, droppableID, getDroppableID, getDraggableID } = options;\r\n  const droppableItems = items.filter(x => getDroppableID(x) === droppableID);\r\n  const idsMap = createBooleanMap(droppableItems, x => getDraggableID(x));\r\n  const [removed] = droppableItems.splice(sourceIdx, 1);\r\n\r\n  droppableItems.splice(destinationIdx, 0, removed);\r\n\r\n  const result = [...items.filter(x => !idsMap[getDraggableID(x)]), ...droppableItems];\r\n\r\n  return result;\r\n}\r\n\r\ntype MoveOptions<T> = {\r\n  items: Array<T>;\r\n  getDroppableID: (x: T) => ID;\r\n  setDroppableID: (x: T, droppableID: ID) => void;\r\n  getDraggableID: (x: T) => ID;\r\n} & OnDragEndOptions;\r\n\r\nfunction move<T>(options: MoveOptions<T>) {\r\n  const { items, destinationIdx, droppableID, draggableID, getDroppableID, getDraggableID, setDroppableID } = options;\r\n  const droppableItems = items.filter(x => getDroppableID(x) === droppableID);\r\n  const idsMap = createBooleanMap(droppableItems, x => getDraggableID(x));\r\n  const idx = items.findIndex(x => getDraggableID(x) === draggableID);\r\n  const item = items[idx];\r\n\r\n  setDroppableID(item, droppableID);\r\n  items.splice(idx, 1);\r\n  droppableItems.splice(destinationIdx, 0, item);\r\n\r\n  const result = [...items.filter(x => !idsMap[getDraggableID(x)]), ...droppableItems];\r\n\r\n  return result;\r\n}\r\n\r\nexport { reorder, move };\r\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__787__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","CONTEXT_ID_ATTR","DROPPABLE_ID_ATTR","DRAGGABLE_ID_ATTR","DRAGGABLE_HANDLER_ATTR","setStyles","node","style","namesMap","maxWidth","maxHeight","zIndex","transformOrigin","keys","propertyName","setProperty","removeStyles","getPropertyValue","removeProperty","getAttribute","removeAttribute","removeStyleAttrIfEmpty","getItemNodes","contextID","droppableID","Array","from","document","querySelectorAll","detectIsActiveDraggableNode","activeDraggableID","getActiveDraggableNode","querySelector","getScrollContainer","getComputedStyle","excludeStaticParent","position","overflowRegex","body","parentElement","test","overflow","overflowY","overflowX","safeNumber","precision","Number","toFixed","createBooleanMap","items","getID","reduce","acc","x","debounce","fn","timeout","timerID","clearTimeout","setTimeout","args","createPointer","e","clientX","clientY","DragDropContext","props","children","onDragStart","onDragOver","onDragEnd","useMemo","nextContextID","useReducer","reducer","inititalState","state","dispatch","mergeState","resetState","onComplete","isDragging","isIntersected","activeDroppableID","nodeWidth","nodeHeight","scrollContainer","unsubscribers","onInsertPlaceholder","useEffect","createElement","setAttribute","textContent","head","appendChild","removeChild","Context","Provider","defaultProps","createContext","activeDroppableGroupID","action","useDragDropContext","useContext","Droppable","dragDropContext","isActive","updatingKey","DroppableInner","memo","droppableGroupID","direction","transitionTimeout","transitionTimingFn","debounceTimeout","disabled","isSomeDragging","isActiveGroup","rootRef","useRef","nearestNodeRef","scope","removePlaceholder","nodes","current","options","length","transform","useBackwardTransitionEffect","rootNode","onIntersect","handleDragMove","target","Document","draggableNode","droppableRect","getBoundingClientRect","draggableRect","draggableRectTop","top","draggableRectLeft","left","droppableRectTop","droppableRectLeft","droppableRectHeight","height","droppableRectWidth","width","targetNode","pointer","addEventListener","unsubscribe","removeEventListener","push","performUnsubscribers","useIntersectionEffect","transformNodesByTarget","onMarkNearestNode","nearestNode","draggableID","container","useLayoutEffect","inner","flex","requestAnimationFrame","transition","fromDragEnd","usePlaceholderEffect","transformNodesByTargetOptions","useDragMoveEffect","handleDragEnd","forEach","splice","hasTransform","window","applyTransition","applyTargetNodeTransition","useDragEndEffect","sourceIdx","findIndex","targetNodeRect","isMoving","destinationIdx","nodeRect","vertical","horizontal","contextValue","DroppableContext","ref","snapshot","defaultHandleDragStart","prevProps","nextProps","preventDefault","targetNodeStyle","isVertical","droppableNode","getActiveDroppableNode","paddingTop","parseInt","paddingLeft","droppableTop","droppableLeft","getDroppableContainerOffsets","offset","marginTop","marginLeft","getHorizontalDirectionOffset","styles","targetRect","minimalDiff","Infinity","fns","rect","thresholdY","innerHeight","thresholdX","innerWidth","getThreshold","map","diff","idx","Draggable","DraggableInner","removeSensor","rootProps","draggable","draggableProps","onPointerDown","startEvent","isPrimary","buttons","marginBottom","marginRight","startPointer","nativeEvent","moveEvent","movePointer","y","getCoordinates","transformNodePosition","isRoot","element","velocity","isTop","isBottom","isRight","isLeft","dy","scrollY","scrollTop","dx","scrollX","scrollLeft","scroll","behavior","syncScroll","syncMove","setNodeDragStyles","removeNodeStyles","reorder","getDroppableID","getDraggableID","droppableItems","filter","idsMap","removed","move","setDroppableID","item"],"sourceRoot":""}